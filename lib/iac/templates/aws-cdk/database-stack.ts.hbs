import * as cdk from 'aws-cdk-lib';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';
import { Construct } from 'constructs';

export interface {{pascalCase projectName}}DatabaseStackProps extends cdk.StackProps {
  vpc: ec2.IVpc;
  environment: string;
}

export class {{pascalCase projectName}}DatabaseStack extends cdk.Stack {
  public readonly database: rds.DatabaseInstance;
  public readonly secret: secretsmanager.ISecret;

  constructor(scope: Construct, id: string, props: {{pascalCase projectName}}DatabaseStackProps) {
    super(scope, id, props);

    // Database credentials secret
    const dbSecret = new secretsmanager.Secret(this, 'DBSecret', {
      secretName: `{{kebabCase projectName}}-${props.environment}-db-credentials`,
      generateSecretString: {
        secretStringTemplate: JSON.stringify({ username: '{{database.username}}' }),
        generateStringKey: 'password',
        excludePunctuation: true,
        includeSpace: false,
        passwordLength: 32,
      },
    });

    // Security group for database
    const dbSecurityGroup = new ec2.SecurityGroup(this, 'DBSecurityGroup', {
      vpc: props.vpc,
      description: 'Security group for {{projectName}} database',
      allowAllOutbound: true,
    });

    {{#if database.allowPublicAccess}}
    dbSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp({{database.port}}),
      'Allow database access from anywhere'
    );
    {{else}}
    dbSecurityGroup.addIngressRule(
      ec2.Peer.ipv4(props.vpc.vpcCidrBlock),
      ec2.Port.tcp({{database.port}}),
      'Allow database access from VPC'
    );
    {{/if}}

    // Database subnet group
    const subnetGroup = new rds.SubnetGroup(this, 'DBSubnetGroup', {
      description: 'Subnet group for {{projectName}} database',
      vpc: props.vpc,
      vpcSubnets: {
        subnetType: ec2.SubnetType.{{#if database.allowPublicAccess}}PUBLIC{{else}}PRIVATE_WITH_EGRESS{{/if}},
      },
    });

    // {{database.engine}} Database Instance
    this.database = new rds.DatabaseInstance(this, 'Database', {
      engine: rds.DatabaseInstanceEngine.{{#eq database.engine "postgres"}}postgres({
        version: rds.PostgresEngineVersion.VER_15,
      }){{/eq}}{{#eq database.engine "mysql"}}mysql({
        version: rds.MysqlEngineVersion.VER_8_0,
      }){{/eq}},
      instanceType: ec2.InstanceType.of(
        ec2.InstanceClass.{{uppercase database.instanceClass}},
        ec2.InstanceSize.{{uppercase database.instanceSize}}
      ),
      credentials: rds.Credentials.fromSecret(dbSecret),
      vpc: props.vpc,
      vpcSubnets: {
        subnetType: ec2.SubnetType.{{#if database.allowPublicAccess}}PUBLIC{{else}}PRIVATE_WITH_EGRESS{{/if}},
      },
      securityGroups: [dbSecurityGroup],
      subnetGroup,
      databaseName: '{{snakeCase projectName}}',
      allocatedStorage: {{database.storage}},
      maxAllocatedStorage: {{multiply database.storage 2}},
      storageType: rds.StorageType.{{#if database.performanceInsights}}GP3{{else}}GP2{{/if}},
      {{#if database.multiAZ}}
      multiAz: true,
      {{/if}}
      {{#if database.enableBackup}}
      backupRetention: cdk.Duration.days({{database.backupRetention}}),
      {{/if}}
      deletionProtection: {{#eq environment "production"}}true{{else}}false{{/eq}},
      removalPolicy: {{#eq environment "production"}}cdk.RemovalPolicy.SNAPSHOT{{else}}cdk.RemovalPolicy.DESTROY{{/eq}},
      {{#if database.performanceInsights}}
      enablePerformanceInsights: true,
      performanceInsightRetention: rds.PerformanceInsightRetention.DEFAULT,
      {{/if}}
      {{#if database.autoMinorVersionUpgrade}}
      autoMinorVersionUpgrade: true,
      {{/if}}
      publiclyAccessible: {{database.allowPublicAccess}},
    });

    this.secret = dbSecret;

    // CloudWatch alarms
    {{#if monitoring.enabled}}
    const cpuAlarm = this.database.metricCPUUtilization().createAlarm(this, 'CPUAlarm', {
      threshold: 80,
      evaluationPeriods: 2,
      alarmDescription: 'Alert when CPU exceeds 80%',
    });

    const connectionsAlarm = this.database.metricDatabaseConnections().createAlarm(this, 'ConnectionsAlarm', {
      threshold: {{multiply database.maxConnections 0.8}},
      evaluationPeriods: 2,
      alarmDescription: 'Alert when connections exceed 80% of max',
    });

    const storageAlarm = this.database.metricFreeStorageSpace().createAlarm(this, 'StorageAlarm', {
      threshold: {{multiply database.storage 0.2 1073741824}}, // 20% of allocated storage in bytes
      evaluationPeriods: 1,
      comparisonOperator: cdk.aws_cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,
      alarmDescription: 'Alert when free storage is less than 20%',
    });
    {{/if}}

    // Stack outputs
    new cdk.CfnOutput(this, 'DatabaseEndpoint', {
      value: this.database.dbInstanceEndpointAddress,
      description: 'Database endpoint address',
      exportName: `{{pascalCase projectName}}-${props.environment}-db-endpoint`,
    });

    new cdk.CfnOutput(this, 'DatabasePort', {
      value: this.database.dbInstanceEndpointPort,
      description: 'Database port',
      exportName: `{{pascalCase projectName}}-${props.environment}-db-port`,
    });

    new cdk.CfnOutput(this, 'DatabaseSecretArn', {
      value: dbSecret.secretArn,
      description: 'Database credentials secret ARN',
      exportName: `{{pascalCase projectName}}-${props.environment}-db-secret-arn`,
    });

    // Tags
    cdk.Tags.of(this).add('Project', '{{projectName}}');
    cdk.Tags.of(this).add('Environment', props.environment);
    cdk.Tags.of(this).add('ManagedBy', 'CDK');
  }
}
